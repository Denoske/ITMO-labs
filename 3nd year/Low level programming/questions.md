# Вопросы для подготовки к экзамену

(2023)

- Если ответ на вопрос уже звучал (учащийся мог его слышать) -- вариант на этот вопрос генерируется повторно (для индивидуального варианта и доп. вопросов).

## Для всех групп

### Вопрос_1. Что такое компьютерная система? Отличие информационной и управляющей системы? Почему большинство современных компьютерных систем считаются системами с преобладающей программной составляющей? Примеры. Понятие информационного процессора.

Компьютерная система - Любая система, оснащённая внутренними алгоритмами управления. (светодиодная лампа, кабели для зарядки мобильных телефонов, компьютер и т.п.) Такое шиорокое определение обусловлено современными реалиями, когда практически любой микроконтроллер будет по мощности превосходить мэйнфреймы времён появления определения ЭВМ.

Большинство систем являются системами с преоблдающей программной составляющей так как для большинства систем (кроме тех у которых полностью кастомный hardware), основная стоимость раззработки и основная реализация управляющих алгоритмов находится на стороне ПО. Это позволяет нам применять по отношению к современным компьютерным системам методологию из чисто программных систем(стандарты из области системной и программной инженерии например). 

Информационные системы - Система, которая получает информацию, видоизменяет/сохраняет её и передаёт её дальше (Word, браузер и т.п.). Основной приоритет для таких систем - производительность. Особенности - Спекулятивные вычисления, Параллелизм, Кластерные и облачные вычисления. 

Управляющие системы - системы, взаимодействующие с реальным физическим миром с целью контроля или управления. Особенности - встроенное исполнение (ограниченные ресурсы, специализированная аппаратура), работа в режиме реального времени(предсказуемая работа в заданное время), автономная эксплуатация. Пример - Видеокодек в медипроигрывателе (скорость работы должна быть ровно такой, чтобы правильно обработать файл. Если это делать медленнее или быстрее, то видео будет проиграно некорректно).

Конечно существуют системы, совмещающие информационные и упраляющие. 

То есть для информационных систем фокус - скорость их работы, для управляющих - их предсказуемость. 

Информационный процессор - Процессор, который в ответ на команду выполняет действие над концептуальной схемой и/или информационной базой. (http://csa.edu.swampbuds.me/08-09-10-processors-von-neumann-cisc-risc-stack.md#/1/1)


### Вопрос_2. Системная инженерия. Понятие системы. Варианты рассмотрения систем. Модульность. Жизненный цикл. Операционное окружение и обеспечивающие системы. Заинтересованные стороны (stakeholders). Проблема передачи информации при разработке компьютерных систем.

Системная инженерия (SE) — это междисциплинарный подход и средство, позволяющее реализовать успешные системы. Он фокусируется на целостном и одновременном понимании потребностей заинтересованных сторон (стейкхолдеров); изучении возможностей; документировании требований; и синтезе, проверке, приемке и разработке решений при рассмотрении всей проблемы, от исследования концепции системы до вывода системы из эксплуатации.

Система - совокупность взаимодействующих элементов, организованных для достижения одной или нескольких заданных целей. 

Идентичность системы определяется её функциональным местом.

Определение можно сузить, взглянув на конкретную рассматриваемую систему (на её задачи, предоставляемые функции). 
Или можно добавить уточняющее слово. Например aircraft system, computer system. 

Операционное окружение системы - окружение в которое встраивается система, то, какие в его рамках к системе выдвигаются требования и то, с чем система в его рамках будет взаимодействовать в ходе своей работы. Операционное окружение - важный фактор в определении требований к системе. 

Жизненный цикл системы:
	1. Концептуальный этап
	2. Этап разработки
	3. Этап производства
	4. Этап эксплуатации (утилизации(utilization))
	5. Этап поддержки
	6. Этап вывода из эксплуатации

Обеспечивающие системы — система, которая дополняет интересующую систему на этапах ее жизненного цикла, но не обязательно вносит непосредственный вклад в ее функционирование во время эксплуатации.
ПРИМЕЧАНИЕ 1 Например, когда система, представляющая интерес, вступает в стадию производства, требуется вспомогательная производственная система.
ПРИМЕЧАНИЕ 2 Каждая обеспечивающая система имеет свой собственный жизненный цикл. Этот Международный стандарт применим к каждой обеспечивающей системе, когда она сама по себе рассматривается как система, представляющая интерес.

Разработка успешной системы требует: 
	рассмотрения её структуры
	рассмотрения её операционного окружения
	рассмотрения особенностей её жизненного цикла
	рассмотрения её обеспечивающих систем

Заинтересованные стороны(stakeholders) - люди имеющие интерес к или влияние на систему. Такие как пользователи, клиенты, спонсоры, регуляторы или поставщики. Разработчики тоже входят в это понятие.

Проблема передачи информации при разработке компьютерных систем - ввиду:
	различий компетенций людей, работающих над системой
	неэффективно расставленых приоритетов разработки
	замены одной задачи на другую
	изменений требований к системе
	чрезмерно шаблонно выстроенного процесса разработки
некоторая информация при передаче между разработчиками, а также людьми, заинтересованными в системе, может быть утеряна. 



### Вопрос_3. Цели и задачи архитектурного проектирования компьютерных систем, его эффект. Понятие архитектуры. Различные трактовки (Гради Буч, ISO 42010 и д.р.) и их практическая значимость.


Цели и задачи архитектурного проектирования компьютерных систем, его эффект: 
	
	Целью архитектурного проектирования компьютерных систем является создание высококачественной, эффективной и надежной системы, которая удовлетворяет требованиям заказчика и пользователей. Архитектурное проектирование включает в себя определение общей структуры системы, ее компонентов и интерфейсов между ними.

	Задачи архитектурного проектирования включают:
	1. Определение требований к системе: архитектор должен понимать, какие функциональные и нефункциональные требования предъявляются к системе, чтобы разработать соответствующую архитектуру.
	2. Разработка концептуальной модели: архитектор должен создать модель системы, которая будет описывать ее общую структуру и компоненты.
	3. Определение архитектурных решений: архитектор должен выбрать технологии, платформы и инструменты, которые будут использоваться для реализации системы.
	4. Проектирование интерфейсов: архитектор должен определить, как компоненты системы будут взаимодействовать друг с другом, чтобы обеспечить эффективную и надежную работу системы.
	5. Оценка рисков: архитектор должен оценить риски, связанные с разработкой и эксплуатацией системы, и определить меры для их снижения.
	6. Создание документации: архитектор должен создать документацию, которая будет описывать архитектуру системы и ее компоненты.

	Эффект от архитектурного проектирования компьютерных систем заключается в создании высококачественной, эффективной и надежной системы, которая удовлетворяет требованиям пользователей и заказчика. Хорошо спроектированная система обеспечивает легкость сопровождения и расширения, что позволяет снизить затраты на ее эксплуатацию. Кроме того, хорошо спроектированная система обеспечивает высокую производительность и масштабируемость, что позволяет обеспечить эффективную работу системы в условиях высоких нагрузок.

Архитектура:
	
	По Гради Бучу:
		Архитектура
			логическая и физическая структура компонентов системы и их взаимосвязи, сформированные всеми стратегическими и тактическими проектными решениями, применяемыми во время разработки. 
		Логический взгляд
			на систему учитывает концепции, созданные в концептуальной модели, и устанавливает существование и роль ключевых абстракций и механизмов, которые будут определять архитектуру и общий дизайн системы. 
		Физическая модель
			системы описывает конкретный программный и аппаратный состав реализации системы. Очевидно, что физическая модель зависит от конкретной технологии. 
^ Тут у нас 2 части - концептуальная часть и физическая
	
	По ISO 42010:
		Архитектура
			- фундаментальные концепты или свойства системы в её окружении, олицетворяемые её элементами, отношениями и принципами её дизайна и эволюции. 
		Описание архитектуры
			- производственный продукт, используемый для описания архитектуры
			Нет единого понятия того, что необходимо или фундаментально для любой системы. Эта характеристика может относиться/включать:
				составляющие системы
				как и в каких отношениях её элементы расположены относительно друг друга
				принципы организации и дизайна системы
				принципы эксплуатации и эволюции системы в процеесе её жизненного цикла
^ Тут у нас всё вместе. Физ. и Лог. представления рассматриваются вместе
	
	Интернет:
		архитектура - набор решений, которые если сделаны неправильно могут привести к провалу/отмене проекта

	Eoin Woods (SEI 2010):
		Архитектура программного обеспечения (ru) — это набор проектных решений, которые, если они будут приняты неправильно, могут привести к отмене вашего проекта.

	Таким образом, можно приближённо сказать, что архитектура - это всё то, что для рассматриваемой системы является важным, оказывающим на неё непосредственное влияние. 


### Вопрос_4. Реле как базис компьютерной системы. Область применения и принципы построения систем на базе реле. Примеры релейных схем и принцип их функционирования. Формирование логического базиса.

Реле - элемент автоматических устройств, который в зависимости от некоторого внешнего влияния, либо пропускает ток, либо нет. 

В контексте компьютера речь идёт об электрических реле. Электрическое реле состоит из: магнитной катушки, ключа, входа и выхода. В завимости от состояния ключа, реле, получая ток на вход, будет либо пропускать этот ток на выоход, либо нет. 
На основе комбинаций из реле можно реализовать простейшие логические операции (AND OR NOT(полный набор булевых функций)). А на этих операций уже все остальные.

В совреенных компьютерах реле были заменены на транзисторы. Тем не менее, реле до сих пор используются в быовой технике (автоматическое включение и выключение), электродвигателях. 

Пример: при последовательном соединении реле мы получим AND, при параллельном - OR. 


### Вопрос_5. Принципы кодирования информации в компьютерных системах. Двоичный код, достоинства и недостатки. Машинное слово и адресация. Код грея, BCD, Base64.

Логические 1 и 0 кодируются на самом низком уровне как электрический сигнал. Существует диапазон напряжения для 1 и для 0. Таким образом, скажем, что для 1 - y и для 0 - x. Все сигналы >=y интерпретируются как 1, все сигналы <=x интерпретируются как 0. При этом существует диапазон (x, y) в котором значение напряжения интерпретируется случайно (forbidden zone). 

Двоичное кодирование:
	
	Достоинства:
		1. Надёжно и помехоустойчиво (в отличие от аналоговой схемотехники, ошибки не накапливаются)
		2. Арифметику просто реализовать
		3. Диапазоны и точность наращиваются с разрядностью
		4. Погрешности "by design" а не "by implementation" (В отличие от аналоговой схемотехники, достаточное качество производства строго определено. Появляется одинаковость результатов работы между устройствами, произведёнными в разных местах)

	Недостатки:
		1. Трудночитаемое представление 
		2. Простые десятичные дроби записываются в виде бесконечных дробей
		3. Дискретное кодирование (точность)

Код Грея:
	
	изменённый двоичный код, в котором две соседние кодовые комбинации отличаются только 1 цифрой в 1 соседнем двоичном разряде. Был разработан для реализации в системах, подверженных помехам при передаче сигнала. 

BCD:
	
	Форма записи рациональных чисел, когда каждый десятичный разряд числа записывается в виде его четырёхбитного двоичного кода. Единственный плюс - человекочитаемость. Раньше большинство процессоров имело встроенный инструментарий для работы с BCD. Позднее, от использования BCD стали отказываться, так как люди, работающие с компьютерами в своей массе осознали концепцию двоичного кодирования и работы с числами в разных системах счисления. Так например при переходе с x86 на x86_64 intel убрали из набора инструкций BCD-инструкции, чтобы закодировать на их месте что-то более полезное. 

Base64:
	
	 Стандарт кодирования двоичных данных при помощи только 64 ASCII символов. (A-Z, a-z, 0-9, 2 доп символа). Кодирование имеет ширину 6 бит. 

Машинное слово - единица данных, естественная для обработки вычислительной системой.

Существует 2 варианта порядка байтов - Big endian и little endian. Big endian - слева направо от старшего к младшему, аналогично тому, как человек записывает десятичные числа. little endian - старший справа, младший слева(от младшего к старшему). 
Преимущество little endian в том, что в случае расширения единицы хранения, появившиеся нули будут незначащими. 
Некоторые современные архитектуры поддерживают оба порядка и позволяют совершать переключение между ними. 


### Вопрос_6. Что такое комбинационная схема? Состояние и параллелизм в комбинационных схемах и схемах с регистрами, переходные процессы. Чтение и запись значений в регистры. Состояние `x` и `z`. Параллелизм уровня битов. Особенности поведения комбинационных схем по сравнению с программами.

Комбинационная схема - схема, составленная из набора логических элементом, в совокупности реализующая заданную таблицу истинности. 
Реализация каких-то функций с помощью булевой алгебры. 
Таким образом, это создание какой-то таблицы истинности, напрямую коррелирующей с отображением ограниченного множества A на ограниченное множество B.

Свойства комбинационных схем:
	
	1. приход схемы в стабильное состояние при корректном входе.
	2. задержка установления стабильного состояния после изменения входных значений
	3. параллелизм уровня бит (узлы схемы работают параллельно)
	4. Накопление ошибки в физическом процессе может привести к ошибке на логическом уровне (использование буферов, то есть элементов, которые будут восстанавливать электрический сигнал до нужного уровня между операциями)

В схемотехнике кроме 0 и 1 есть состояния z и x.
	
	z - отключено, настоящий электрический 0.
	x - неизвестно, произвольное значение, выдаваемое функцией, при выходе за её диапазон значений. 

Результаты работ функций реализованных комбинационными схемами нужно куда-то сохранять. Для этого существуют триггеры. 
Триггер — класс электронных устройств, обладающих способностью длительно находиться в одном из двух устойчивых состояний и чередовать их под воздействием внешних сигналов.
	
	D триггер
		- запоминает состояние входа и выдаёт его на выход

	RS триггер
		- асинхронный триггер, сохраняющий своё предыдущее состояние при неактивном состоияни обоих входов. Изменяет состояние при подаче на один из его входов активного уровня сигнала. 

Из множества триггеров в современных компьютерах формируются регистры. 

хранение Состояний позволяет:
	
	хранить состояния (ценно само по себе)
	Производить вычисления в несколько шагов, то есть строить многотактовые схемф
	Реализовывать конвейрное исполнение (количество стадий определяет количество параллельно выполняемых задач)
	Производить итеративные расчёты
	Реализовывать программное управление



### Вопрос_7. Аппаратное обеспечение. Виды монтажа и особенности производства. Навесной и поверхностный монтаж. Интегральные схемы. Проблемы, специфичные для аппаратного обеспечения: производство, эксплуатация, устаревание.

Способы монтажа(сборки) электронных схем:
	
	Навесной монтаж
		- способ монтажа при котором расположенные на изолирующем шасси радиоэлементы соединяются друг с другом проводами. Хрупок, недолговечен, пока не залит эпоксидной смолой, после чего уже не разбираем.

	Монтаж на макетной плате
		- подсоединение компонентов и их расположение на специальной макетной плате. Простой и доступный способ ввиду низкой цены, лёгкости сборки и гибкости. Тем не менее, неприменим для серийного, массового наукоёмкого производства ввиду сложности автоматизации сборки, высокой цены в серийном масштабе, проблем с помехами и точность, пока не залита эпоксидной смолой, что опять делает конструкцию неразборной. 

Печнатная плата - пластина из диэлектрика, на поверхности и/или в объёме которой сформированы электропроводящие цепи электронной схемы. Электрическое и механическое соединение компонентов.
	
	Монтаж на печатную плату
		- помещение всех соединений и компонентов на жёсткую печатную плату. Высокая плотность элементов, минимизация внешних помех. Общепринятый способ монтажа в современных компьютерах. Тем не менее, нереализуем любителем, требует промышленного фабричного производства. 

	Для помещения элемента на печатную плату используется поверхностный монтаж - на поверхности платы есть контактная площадка (слой меди), на него капают припоем, ставится элемент и припаевается. В результате получается жёсткая сцепка между компонентами. 

Таким образом, монтаж на печатную плату с помощью поверхностного монтажа хорошо подходит для автоматизации, то есть для промышленного производства электроники. 

	Также существует встроенный монтаж - монтаж элементов внутри платы, что позволяет делать могослойные платы. 

Интегральная схема (микросхема) - электронная схема произвольной сложности, изготовленная на полупроводниковой подложке (печатной плате) и помещённая в неразборный корпус. Часто интегральной схемой нахывается сама схема, до помещения её в корпус. 


Проблемы:
	
	Производство:
		Современные интегральные схемы невероятно трудоёмки и дороги в изготовлении ввиду своих масштабов.
		Ввиду вышеописанной сложности, часто результирующая интегральная схема получается хуже по своим параметрам, чем другие, произведённые прямо перед/за ней. Многие компании-производители процессоров продают такие процессоры как представителей "младшей" линейки с более слабыми характеристиками. 

	Эксплуатация:
		Электронные компоненты со времененм теряют свои свойства. 
		Для решения проблем с аппаратурой необходим непосредственный физический доступ. 
		Внешняя среда может оказывать вредное влияние на аппаратуру
		Различные долгосрочные эффекты. Например, оловянный припой со временем отращивает из себя нити, которые, коснувшись других элементов, могут привести к короткому замыканию.

	Поддержка:
		Отладка современных плат является сложным физическим процессом, требующим особых навыков и специальной аппаратуры.
		Сложность изменений: даже физический доступ к аппаратуре является ограниченным и очень многие ошибки этапов проектирования и производства не могут быть никак исправлены.
		Обслуживание стареющей аппаратуры. Старая аппаратура закономерно выходит из строя, элементной базы для замены больше не производят, так как старые линии производства постоянно заменяются на новые. 



### Вопрос_8. 2-этапное производство, варианты обеспечения. Понятия Hardware и Software, их свойства. Сравнение с понятиями программного и аппаратного обеспечения. Особенности. Причины разделения. Принципы совместного проектирование (HW/SW CoDesign).

Наличие в компьютерных системах аппаратной составляющей вводит большое количество проблем производства, эксплуатации и поддержки. Для решения, или скорее, смягчения этих проблем существует 2-этапное производство.  (проблемы см в 7 вопросе)

2-ух Этапное производство:
	
	- Производство относительно универсальной компьютерной системы (Hardware)
	- Настройка прикладного поведения (Software)

Обеспечение 2-этапного производства: в аппаратуру должны быть заложены при проектировании различные возможности конфигурации:
	
	1. На уровне сборки (Джамперы, платы расширения) 
		https://ru.wikipedia.org/wiki/%D0%94%D0%B6%D0%B0%D0%BC%D0%BF%D0%B5%D1%80
		https://ru.wikipedia.org/wiki/%D0%9A%D0%B0%D1%80%D1%82%D0%B0_%D1%80%D0%B0%D1%81%D1%88%D0%B8%D1%80%D0%B5%D0%BD%D0%B8%D1%8F

	2. Реконфигурации (Коммутации) ПЛИС, FPGA, CGRA
		https://ru.wikipedia.org/wiki/%D0%9F%D0%9B%D0%98%D0%A1
		https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D1%83%D0%B5%D0%BC%D0%B0%D1%8F_%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%BC_%D0%B2%D0%B5%D0%BD%D1%82%D0%B8%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%BC%D0%B0%D1%82%D1%80%D0%B8%D1%86%D0%B0

	3. Программирования, настройки

Hardware, Software, сравнение с аппаратурой и ПО:

Аппаратное обеспечение - электронные и механические части вычислительного устройства, входящие в состав системы или сети, исключая программное обеспечение и данные (информацию, которую вычислительная система хранит и обрабатывает). Аппаратное обеспечение включает: компьютеры и логические устройства, внешние устройства и диагностическую аппаратуру, энергетическое оборудование, батареи и аккумуляторы. 

ПО - совокупность программ, системы обработки информации и программных документов, необходимых для эксплуатации. Позволяет аппаратному обеспечению вычислительной системы выполнять вычисления или функции управления. 

Software - То, то легко изменить/сконфигурировать в компьютерной системе, Hardware - То, что тяжело. В отрыве от привязки к аппаратной и не аппаратной части компьютерной системы. 

Таким образом, переходя на определения SW/HW с аппаратуры/ПО, мы отвязываем определения от физических концептов, которые не могут с должной точностью описать обсждаемую нами тематику. (ПЛИС - это ПО или аппаратура? HW или SW?)

Таким образом, SW/HW больше опирается на способ использования обсуждаемого предмета. 

Для удобства можем подвязать новые понятия со старыми - HW совпадает с аппаратной составляющей, если нет альтернативы (питание, антенны, аналоговые сигналы (их не виртуализируешь))

Типовая точка зрения на разрабатываемую систему:
Пишем програму----Проектируем аппаратуру

Обычно аппаратуру и ПО разрабатывают отдельно. Проблемы: излишне шаблонное проектирование, затягивание сроков.

SW/HW Codesign - разработка компьютерной системы не как сначала HW, потом SW по отдельности, а совместное проектирование конечной модели, с уже последущим разбиением на разные этапы. Это позволяет уменьшить время, затрачиваемое на разработку, а также уменьшает шаблонность разрабатываемых HW и SW, составляющих копмьютерную систему. (СМ скриншот 1.png)


Вопрос_9. Понятие модели вычислений (MoC). Сопоставление понятия парадигмы программирования и MoC. Примеры MoC (последовательные, параллельные, функциональные) и их роль в разработке компьютерных систем. Использование MoC в разных вычислительных платформах.

MoC представляет язык для описания моделей процессоров/программ. Определяет возможности вычислительной машины. Характеризует, как исполняется программа(какие могут быть состояния вычислителя, их последовательность, правила переходов). МоС минималистичны относительно реальных вычислителей.

Таким образом, МоС хороши, чтобы понять какие-то основопологающие принципы работы системы, или оценить алгоритм. Пытаться экстраполировать МоС в полной мере на реальность не стоит. 

МоСы:
	
	Последовательные модели:
		Позволяют описать последовательный алгоритм, чьи составляющие могут быть сведены к последовательностям изменений состояния. (Пример - машина Тьюринга)

	Функциональные модели:
		Позволяют описать вычислительный процесс в символьной форме и как список правил. (Пример - Лямбда счисление, Комбинаторная логика)

	Параллельные модели:
		Применяются к системе, чей процесс работы включает в себя несколько взаимодействующих процессов. Эти процессы обычно описывает другая МоС. (Мобильная связь, синхронная передача данных)

	На основе этих моделей существуют распределённые модели. 

Близкие понятия МоС: парадигма программирования(Хотя все современные языки мультипарадигменны), Стиль программирования конкретного человека. 

По большому счёту, с МоС работают люди, разрабатывающие алгоритмы. 

МоС на практике:
	
	1. Computer Science - создание алгоритмов и формальных моделей
	2. Дизайн языков программирования
	3. Управление сложностью 
	4. Ограничение творческого порыва отдельных программистов
	5. Модель-ориентированная инженерия



### Вопрос_10. Универсальный процессор и его свойства. Машина Тьюринга и полнота по Тьюрингу. Виды процессоров (СБИС, FPGA, CGRA, GPU, DSP, CPU) и их сопоставление с точки зрения универсальности и эффективности.

Для реализации 2-ух этапной разработки, на стороне Hardware необходим так называемый универсальный процессор. 

Универсальный процессор - процессор, который позволяет решать широкий круг задач, настройка которых производится после производства "по месту" или в run-time.

Стоит отметить, что в данном случае универсальность не значит полноту по Тьюрингу. А также, что теоретическая универсальность не значит практическую. К тому же универсальность вредит эффективности. 

Свойства универсального процессора: 
	
	1. 2-ух этапное проектирование
	2. Полнота по Тьюрингу ???
	3. Отсутствие "серьёзных" ограничений на объём программы
	4. Изменяемость ПО

Можно сравнить разные существующие процессоры по соотношению эффективности и универсальности:
	
	Схема на кристалле (СБИС) - это тип процессора, который представляет собой полностью интегрированную схему, в которой все компоненты, включая процессорное ядро, память и периферийные устройства, расположены на одном кристалле. СБИС-процессоры обладают высокой производительностью и эффективностью, но они также являются дорогостоящими и сложными в разработке.

	FPGA - Программи́руемая по́льзователем ве́нтильная ма́трица, полупроводниковое устройство, которое может быть сконфигурировано пользователем или разработчиком после изготовления. Наиболее трудоёмкая в изготовлении среди ПЛИС. 

	CGRA - Coarse-Grained Reconfigurable Arrays. Похожи на FPGA, но выстраиваются из более комплексных блоков. 

	GPU - Graphics processing unit. Процессоры, созданные специально для проведения расчётов графики. Уже более универсальны, как показывала практика, могут использоваться и для других задач (Например для добычи криптовалюты).

	DSP - Цифровой процессор обработки сигналов

	CPU - Центральный процессор, наиболее универсальный из всего вышеперечисленного, но в конкретных задачах будет уступать специализированным. 

	(См. скриншот 2.png)

Можно отметить, что чем более процессор гибкий в своей конфигурации и программировании, тем менее эффективным он будет в работе с поставленными перед ними задачами. 


Машина Тьюринга - абстрактный исполнитель (абстрактная вычислительная машина). По факту просто каретка, бегающая по бесконечной ленте, с возможностью движения влево или вправо. Программа записывается на этой же ленте. Машина может прочитать за раз лишь 1 ячейку ленты. 

Полнота по Тьюрингу - означает возможность реализации функционала машины Тьюринга на компьютере/языке программирования. 

Микропроцессор - цифровая схема, которая выполняет операции с внешним источником данных (обычно памятью или потоком данных). 

Микроконтроллер - микросхема, предназначенная для управления электронными устройствами. Типичный микроконтроллер сочетает функции процессора и периферийных устройств.



### Вопрос_11. Архитектура фон Неймана. Принципы. Свойства. Особенности и ограничения. Применение на практике. Машинное слово. Понятие системы команд и её роль в построении процессоров. Control Unit и DataPath.

Архитектура процессора (architecture)
	то, как видит компьютер программист. Определена набором команд (язык), местом нахождения операндов (регистры и память) и вычислительными механизмами (кеш, прерывания...). 

Машина фон Неймана:
	
	1. Развитие машины Тьюринга. Ключевые отличия:
			лента заменена на Random-Access Memory (RAM);
			инструкции и данные объединены.
	2. Призвана быть максимально простой в реализации и производстве.

Особенности:
	
	1. Использование двоичного кодирования. (В наше время встречается троичное и двоично-десятичное кодирование)
	2. Программное управление. Команды выполняются последовательно. (В современных суперскалярных архитектурах последовательность и порядок условны)
	3. Память компьютера однородно хранит данные и программы (В современных компьютерах однородность условна)
	4. Ячейки памяти компьютера имеют адреса. RAM. (Сегодня память не является пассивным элементом компьютера)
	5. Возможность условного перехода (В современных компьютерах переходы могут происходить и по другим причинам (прерывания))

Виды инструкций:
	
	1. Работа с памятью (запись констант, копирование данных (память, регистры, порты I/O)).
	2. Арифметические, логические и битовые операции
	3. Управляющие операции (безусловный, условный и косвенный переходы, вызов и возврат из подпрограмм).
	4. Инструкции сопроцессоров (Загрузка и выгрузка данных. Управление сопроцессором.)

В текущем виде не применяется, но вклад неоценим. Все современные процессоры являются развитием архитектуры фон Неймана. 


Система команд процессора
	(Instruction Set Architecture — ISA) абстрактная модель процессора, формирующая интерфейс взаимодействия между программным обеспечением и процессором. 

Машинное слово
	фрагмент данных фиксированного размера, обрабатываемый как единое целое 

{???
Микроархитектура процессора (microarchitecture)
	соединение простейших цифровых элементов в логические блоки, предназначенные для выполнения команд определенной архитектуры.

	1. Описывает, как в процессоре расположены и соединены друг с другом регистры, АЛУ, конечные автоматы, блоки памяти, интерфейсы ввода-вывода и т.п.
	2. У каждой архитектуры может быть много микроархитектур, обеспечивающих разное соотношение производительности, цены, сложности, технической эстетики. Они смогут выполнять одни и те же программы.
	3. Если ISA и микроархитектура отличаются на уровне MoC — обычно требуется уровень виртуализации (ПО, аппаратура. транслятор...).
???}

Control Unit - Компонент CPU, направляющий работу процессора. Обычно использует бинарный декодер для конвертации закодированных инструкций в сигналы, которые руководят работой других компонентов процессора. 

Datapth - ALU, набор регистров, внутренние шины CPU, позволяющие данным проходить через них.

Работа Datapath в разных архитектурах - см скриншоты 3-7.png


### Вопрос_12. Гарвардская архитектура и её отличия от архитектуры фон Неймана. Принципы. Свойства. Особенности и ограничения. Применение на практике. Подходы к обходу ограничений архитектуры. Машинное слово. Control Unit и DataPath.

Гарвардская архитектура - архитектура ЭВМ, отличительными признаками которой являются: хранение инструкций и данных представляют собой разные физические устройства, каналы инструкций и данных также физически разделены. 

В архитектуре фон Неймана процессор в один момент времени может либо читать инструкцию, либо читать/записывать данные в/из памяти. Оба действия происходить не могут, так как для них используется одна и та же шина. А процессор в компьютере Гарвардской архитектуры может считывать очередную команду и оперировать с памятью данных одновременно. Но при этом, схема работы процессора Гарвардской архитектуры, заметно сложнее оного архитектуры фон Неймана. 

Также недостатком классической Гарвардской архитектуры является сложность переноса данных, содержащихся в инструкциях в память и вставки новых данных в память инструкций. 

Таким образом, достоинства Гарвардской архитектуры:
	
	1. 2 физических канала между процессором и памятью
	2. Одновременный доступ к памяти команд и данных
	3. Разная ширина машинного слова и адреса для данных и программ
	4. Изоляция памяти инструкций

Недостатки:
	
	1. Сложность и стоимость реализации
	2. Изоляция инструкций и данных (Запуск результата компиляции и указатели на функции)

{???
Вариации Гарвардской архитектуры:

Архитектура "Память инструкций как данные"
(Instruction-memory-as-data)
	реализуется возможность читать и писать данные в память программ. Позволяет генерировать и запускать машинный код. 

Архитектура "Память данных как инструкции"
(Data-memory-as-instruction)
	реализует возможность запуска инструкций из памяти данных. Позволяет генерировать и запускать машинный код, но параллельный доступ ограничен. 

Модифицированная Гарвардская архитектура (main stream)
	Доступ к памяти реализуется через независимые кеши для данных и программ, за счет чего, с точки зрения внутренней организации процессора, доступ реализован независимо, при этом канал между процессором и 
???}

CU и Datapath см. Вопрос 11


### Вопрос_13. Механизм микроопераций, микропрограммирование и его роль в развитии компьютерных систем. Особенности и ограничения. Применение на практике. Пример оптимизации через микрокод. NISC архитектура.

Микроархитектура процессора

Микроархитектура процессора (microarchitecture)
	соединение простейших цифровых элементов в логические блоки, предназначенные для выполнения команд определенной архитектуры. 

Примечания:
	
	Описывает, как в процессоре расположены и соединены друг с другом регистры, АЛУ, конечные автоматы, блоки памяти, интерфейсы ввода-вывода и т.п.
	У каждой архитектуры может быть много микроархитектур, обеспечивающих разное соотношение производительности, цены, сложности, технической эстетики. Они смогут выполнять одни и те же программы.
	Если ISA и микроархитектура отличаются на уровне MoC — обычно требуется уровень виртуализации (ПО, аппаратура. транслятор...).

При реализации Control Unit существует 2 подхода:
	
	Hardwired - при помощи аппаратных комбинационных схем, декодирующих инструкции в последовательности сигналов.

	Microcoded - при помощи исполнения микропрограммы реализующей необходимые функции

	Микропрограмма(микрокод) - программа, реализующая набор инструкций процессора. 

Таким образом, комплексные инструкции внутри процессора разбиваются на простейшие микроинструкции, напрямую транслирующиеся в управляющие сигналы процессора.

Достоинства такого подхода: 
	
	1. Простота реализации (CISC).
	2. Возможность "программирования" системы команд.
	3. Доступ к микрокоду для программиста.
	4. Генерация ISA под задачу 

Недостатки подхода:
	
	1. Хранение микрокода в процессоре.
	2. CISC долго учить.
	3. Разнообразие архитектур → проблемы инструментария.
	4. Разнообразие команд (форматы, размеры, длительности, доступ). Усложняет: (оптимизацию процессора; инструментарий).
	5. Микрокод привносит проблемы ПО (сложность, отладка) в аппаратуру

No Instruction Set Computer
NISC - идея отказа от системы команд и реализации только микрокода. 

Применяются в ускорителях, спец. вычислителях, высокоуровневом синтезе

Достоинства NISC:
	
	1. Упрощение аппаратуры
	2. Максимальная эффективность программного управления
	3. Нет ISA, нет проблем её проектирования

Недостатки NISC:
	
	1. Невозможность бинарной совместимости (В подходе с микрокодом можно сколь угодно "перекапывать" микроархитектуру без угроз совместимости, пока она предоставляет тот же архитектурнй интерфейс)
	2. Низкая плотность машинного кода


### Вопрос_14. Что такое CISC? Роль в развитии компьютерных систем. Применение на практике. Достоинства и недостатки. Отличия от архитектуры фон Неймана. Особенности программирования.

CISC архитектура процессора (Complex Instruction Set Computer) - Архитектура процессора, в которой единичные инструкции могут представлять собой сразу несколько низкоуровневых внутренних операций процессора.

Например x86 - add qword [0x1234], 100 ; rep stosq

ARM - FJCVTZS %w0, %d1

Достоинства:
	
	1. Высокая плотность кода
	2. Комплексность инструкций позволяет сэкономить время выборки инструкций (вместо выборки и исполнения нескольких простых инструкций исполняется 1 сложная).
	3. Код для CISC архитектур интересно писать

Недостатки:
	
	1. Сложность экстраполяции всех правил программирования CISC архитектуры на компиляторы. 
	2. Сложное внутреннее устройство процессора и Contron Unit.

Какие-то отличия CISC от фон Неймановской архитектуры не выделить - CISC это про ISA, фон Нейман - про Memory layout. 

В CISC архитектурах нет фиксированной ширины инструкций.

Для конвейризации внутри реализуется управление на уровне микрокода. 

Раньше, в условиях слабых компиляторов и большого разнообразия архитектур, на рынке существовало много CISC архитектур. К сегодняшнему дню среди них осталась только x86. 


CISC VS Von Neuman (by GPT):
	
	CISC (Complex Instruction Set Computing) и Von Neumann Architecture (также известная как архитектура фон Неймана) - это две разные концепции в компьютерной архитектуре.

	CISC относится к процессорам, которые используют большое количество сложных инструкций, которые могут выполнять несколько операций за один цикл. Это позволяет сократить количество инструкций, необходимых для выполнения задачи, и ускорить работу процессора. CISC-процессоры также обычно имеют большой объем памяти на кристалле, что позволяет им хранить большое количество инструкций и данных.

	Архитектура фон Неймана, с другой стороны, является основой для большинства современных компьютеров. Она основана на идее того, что данные и инструкции хранятся в одной памяти и обрабатываются одним процессором. Это позволяет процессору быстро получать доступ к данным и инструкциям и обрабатывать их.

	Одним из основных отличий между CISC и фон Нейманом является то, что CISC-процессоры имеют многослойную архитектуру, в то время как архитектура фон Неймана является однослойной. Кроме того, CISC-процессоры обычно имеют большее количество регистров и специализированных инструкций, чем процессоры, основанные на архитектуре фон Неймана.


### Вопрос_15. Что такое RISC? Роль в развитии компьютерных систем. Применение на практике. Достоинства и недостатки. Отличия от архитектуры фон Неймана. Особенности программирования.

Risc - Reduced Instruction Set Computer

RISC находится в дихотомии с CISC. 

Предпосылки к появлению:

	1. Сложные операции встречаются редко и заменимы группами команд
	2. Качественно улучшение возможностей компиляторов

Особенности:

	1. Единый формат инструкций, простота декодера
	2. Место памяти микрокоманд и декодера можно использовать под инструкции и кеш
	3. Оптимизация малого количества однообразных команд
	4. Лёгкость конвейризации команд без нужды микрокода

Главные достоинства - параллелизм уровня инструкций, простота разработки процессора


RISC vs Von Neuman (by GPT):
	
	RISC (Reduced Instruction Set Computing) и архитектура фон Неймана - это две разные концепции в компьютерной архитектуре.

	RISC-процессоры, в отличие от CISC-процессоров, используют набор простых инструкций, которые выполняются за один цикл. Это позволяет ускорить работу процессора и уменьшить сложность его архитектуры. RISC-процессоры также обычно имеют меньшее количество регистров, чем CISC-процессоры.

	Архитектура фон Неймана, с другой стороны, является основой для большинства современных компьютеров. Она основана на идее того, что данные и инструкции хранятся в одной памяти и обрабатываются одним процессором. Это позволяет процессору быстро получать доступ к данным и инструкциям и обрабатывать их.

	Одним из основных отличий между RISC и архитектурой фон Неймана является то, что RISC-процессоры имеют более простую архитектуру, чем процессоры, основанные на архитектуре фон Неймана. Они также обычно имеют меньшее количество инструкций, чем процессоры, основанные на CISC-архитектуре. Кроме того, RISC-процессоры обычно быстрее работают с памятью и имеют более высокую скорость выполнения инструкций.


### Вопрос_16. Конвейеризированное исполнение команд. Стадии конвейера. Виды конфликтов (по данным, по управлению), их примеры и влияние на производительность. Достоинства и недостатки.

Конвейризированное исполнение команд - паралеллизм уровня инструкций. Идея заключается в разбиении инструкции на несколько этапов выполнения и выполнения этих этапов параллельно для разных команд. 

Стадии конвейра представляют собой такты. Один такт - одна стадия конвейра. 

Построение конвейра:
	
	1. Выделить стадии выполнения команд
	2. Организовать внутренние структуры процессора так, чтобы:
		У процессора был входной(поступают команды) и выходной конец(команды покидают процессор)
		Структурв процессора должна соответствовать стадиям выполнения команд
		Сегменты связаны регистрами, комбинационные схемы сбалансированы
		Все части процессора управляются одним тактовым сигналом
	3. загружать в процессор команды каждый такт
	4. Получать результаты выполнения команд каждый такт
	5. Разрешать конфликты выполняемых команд.

Типовые стадии конвейра RISC:
	
	1. Instruction Fetch (Чтение инструкции по счётчику команд)
	2. Instruction Decode (Декодировать инструкцию и считать регистры)
	3. Instruction Execute (Операций изменения данных)
	4. Memory Access (Чтение/запись операндов из памяти/в память)
	5. Write Back (Запись результата в регистры)
Для конкретики можно глянуть скриншот 8.png


### Вопрос_17. Виды конфликтов при работе конвейера и механизмы их разрешения, сокращения их числа. Пузырёк, разворачивание циклов, предсказания переходов (статические и динамические).

	Виды конфликтов при работе конвейра: 
		1. Структурные конфликты (Structural dependency)
		2. Конфликты данных (Data dependency)
		3. Конфликты по управлению (Contral dependency / Branch hazard)

	Структурные конфликты:
		Конфликт из-за ресурсов. Аппаратура не позволяет выполнить все возможные комбинации инструкций.
		Пример: одновременный доступ к единой памяти команд/данных.
		Варианты решения проблемы:
			Гарвардская архитектура
			Двухпортовая память
		Разрешение конфликта пузырьком (см скриншот 9.png)

	Конфликты по данным (Hazards):
		RAW - Read after Write (and r1, 0xf; sub r0, r1)
		WAR - Write after Read - не проблема в общем случае (and r0, r1; sub r1, 100)
		WaW - Write after Write - (and r1, 0xf; sub r1, r0)
		RAR - Read after Read - не проблема (and r0, r1; and r2, r1)
		Разрешение:
			1. исполнение не по порядку. (out of order execution)
			2. Переминование регистров. Если зависимость по данным ложная, запись может быть переназначена на другой регистр.
			3. Вставка пузырька (плохо)
			4. Проброс операндов (bypassing, Operand Forwarding) между стадиями конвейра, минуя регистры (См. скриншот 10.png)

	Конфликты по управлению (Control Dependency, Branch Hazards):
		Конфликт из-за операций условного и/или безусловного перехода
		Проблема: в конвейр загружены команды, которые не должны быть исполнены
		Решения:
			bubble (плохо)
			сброс конвейра
			минимизация количества условных переходов (loop unrolling, условное перемещение данных)
			branch prediction (предсказание переходов)

Barnch prediction - предсказание результатов инструкций условного перехода

Статическое:
	1. Условный переход вперёд скорее не произойдёт (аля if)
	2. Условный перехлд назад скорее произойдёт (аля for)
	3. Некоторые процессоры поддерживают "подсказки" компилятора для предсказаний

Динамическое:
	Внутри процессора формируется таблица из адреса команды с переходом, адреса, предсказанного для перехода, и несколько бит, хранящих результат работы инструкции в прошлые её вызовы. Обычно используется счётчик с накоплением 2 бита. 

2-битовый счётчик называют Saturating counter. 00 - strongly not taken, 01 - weakly not taken, 10 - weakly taken, 11 - strongly taken.

Многоуровневое(Corellation based branch prediction):
	Многоуровневые предсказатели также называются двухуровневыми, так как они используют двумерную таблицу счётчиков, также называемую "Pattern history table". Значение, получаемые из таблицы - 2-битные счётчики. Таким образом, в эту таблицу записываются результаты перехода для предыдущих его вызовов. На основе данных о них, делается вывод о конкретном переходе, исполняемом конвейром. 
	Текст из википедии: (A two-level adaptive predictor remembers the history of the last n occurrences of the branch and uses one saturating counter for each of the possible 2n history patterns. This method is illustrated in figure 3.)

Преимущество конвейризации: повышение уровня производительности и уровня утилизации ресурсов

Недостатки:
	
	Снижение скорости исполнения отдельной команды
	Необходимость разрешения конфликтов
	Непредсказуемое время выполнения
	Уязвимости косвенных каналов (Spectre, Meltdown)


### Вопрос_18. Что такое SOP (Stack-Oriented Processors, стековый процессор)? Роль в развитии компьютерных систем. Применение на практике. Достоинства и недостатки. Отличия от архитектуры фон Неймана. Особенности программирования.

Не имеет регистров. Работает со стеком. У стека есть TOS(Top Of Stack), к которой обычно производится быстрый доступ. 

TOS обычно имеет размер 2, так как при реализации алгоритмов на стековой машине, зачастую работа ведётся с вершиной стека и следующим после неё элементом.

Часто имеет несколько стеков(для данных, для адресов возврата функций) 

Считается High-level language computer architecture.

Достоинства:
	
	1. легко реализовать процедуры, автоматическую память, рекурсию, сложные математические выражения со скобками, простой компилятор
	2. Простая система команд
	3. Cahce-friendly
	4. Threads

Недостатки:
	
	1. Большое количество данных на стеке крайне неудобно для программиста
	2. Обычно не прикрутить параллелизм уровня инструкций
	3. Не получится работать с динамическими структурами данных




### Вопрос_19. Поддержка операций ввода-вывода в фон Неймановских процессорах. Поддержка на уровне системы команд (порт, отображение в память). Программно-управляемый ввод-вывод. Ввод-вывод через механизм прерываний. Механизм прямого доступа к памяти.

Обычно внешнее устройство предоставляет процессору набор регистров, считывая и делая запись в которые по заданному протоколу, процессор может взаимодействовать, получать данные, отправлять данные и программировать устройство. 

Существует 3 варианта ввода-вывода:
	
	1. Программно управляемый - операции реализуются процессором. Все действия реализуются через инструкции процессора.
	2. Ввод-вывод по прерыванию - снимает с процессора задачу наблюдения и позволяет это реализовать по внешнему событию.
	3. Channel I/O и прямой доступ к памяти (Direct Memory Access — DMA) - процессор оповещается об операции завершения ввода-вывода.

С точки зрения ISA ввод-вывод реализуется либо через порты ввода-вывода (in/out в x86), либо через MMIO (Memory mapped input-output), когда регистры внешнего устройства привязываются к адресам в адресном пространстве процессора, то есть запись в память по этому адресу будет эквивалентна записи в регистр устройства, и наоборот с чтением. 

PMIO (Port Mapped Input Output):
	
	Достоинства:
		1. Минимизация логики управления (более простое адресное пространство портов)
		2. Ввод-вывод и доступ к памяти разделены
		3. Адресное пространство памяти остаётся однородно
	Недостатки:
		1. Усложнение ISA процессора
		2. Данные ввода-вывода - данные второго сорта(особенно для CISC cpu). с PMIO только in/out аналогично с RISC ld/st
		3. "Лишние" копирования данных
		4. Адресное пространство портов ограничено

MMIO (Memory Mapped Input Output):
	
	Достоинства:
		1. Может быть реализован без изменения микроархитектуры процессора
		2. Простота процессора
		3. Обработка данных без переноса в память
		4. Адресное пространство памяти огромно, количество устройств не ограничено устройством процессора
	Недостатки:
		1. Одна шина ввода-вывода и доступа к памяти
		2. Неоднородность памяти
		3. Устройства ввода-вывода работают с избыточным адресом
		4. Конфликты с кешами и параллелизмом уровня инструкций

Программно-управляемый ввод-вывод:
	
	Работа с вводом-выводом управляется единым потоком управления. Наблюдаем за состоянием устройства, реагируем.
	Проблемы:
		1. Занимает процессор
		2. Процессор должен регистрировать сигнал на частоте в два раза выше частоты сигнала (Теорема Котельникова)
		3. Высокое энергопотребление
		4. Как совмещать с другими задачами?
		6. Как быть со сложным протоколом ввода вывода?
Можно попытаться применить параллелизм через конечные автоматы, но это также будет давать свой overhead.

-------------------- ПРЕРЫВАНИЯ:

Ввод-вывод через прерывания:
Возможность совершить переход к другой части кода, реагируя на внешнее событие, и потом вернуться обратно. 
Принцип работы:
	
	1. Выполнение основного потока.
	2. Запрос прерывания.
	3. Сохранение адреса возврата.
	4. Вызов обработчика прерывания (ISR) — обычного кода в специальном месте.
	5. Завершение ISR.
	6. Восстановление адреса возврата.
	7. Продолжение основного потока.
Система прерываний обеспечивает минимум два уровня задач:
	
	1. Основной поток исполнения.
	2. Поток (потоки) обработчиков прерываний.
Источники прерываний либо аппаратные, которые, в свою очередь, могут быть внешними(асинхронные для внутренних циклов процессора)(тик таймера, нажатие клавиши) и внутренними(деление на 0, ошибка доступа к памяти), либо программными, то есть вызванными инструкцией. 

Для реализации прерываний обычно аппаратно реализуется контроллер прерываний.
В рамках контроллера реализуется конкурирующая очередь, где разным прерываниям присваивается разный приоритет.

Прерывания бывают маскируемыми и не маскируемыми(возможность отключать ненужные прерывания для сохранения целостности потока исполнения), относительными и абсолютными (прерывания прерываний)

Прерывания, получаемые контроллером бывают:
	
	1. По фронту. A key difference between the edge-triggered and level-triggered interrupts is interrupt sharing. Level-triggered interrupts can be shared. Edge-triggered interrupts cannot be shared(IBM doc).
	2. По уровню (требует "сброса"). By OR — Spurious Interrupts. The interrupt is triggered when the level changes (from inactive to active or asserted); until it's deasserted, the line remains in the asserted state.
	In short, edge interrupt gets fired only on changing edges, while level interrupts gets fired as long as the pulse is low or high.
	3. По сообщению (Message Signaled).
	4. По дверному звонку (Doorbell). Сигнал и информация разделены. (оповещение от устройства и начало работы со считыванием данных устройства не совпадают)

Пример контроллера прерываний и внешнего устройства: 8259 PIC и Intel 8253 в x86.

-------------------- КОНЕЦ ПРЕРЫВАНИЙ

Механизм прямого доступа к памяти:
Для DMA(Direct Memory Access) аппаратно реализуется сопроцессор, Контроллер прямого доступа к памяти. Он вместо cpu выполняет команды переноса данных между памятью устройств ввода-вывода и памятью процессора. 

Контроллер прямого доступа к памяти обычно сам реализован как устройство ввода-вывода. 
В зависимости от разновидности, управление контроллером может осуществляться как сами процессором(Third party), так и устройством ввода-вывода(Bus mastering).

Обычно контроллер прямого доступа памяти работает в одном из этих режимов:
	
	1.Пакетный режим (Burst Mode). Приоритет DMA.(Передача данных осуществляется единой операцией, которая не может быть прервана процессором).
	2. Циклический режим (Cycle stealing mode).Приоритет конфигурируется.(Для процессора и DMA выделяется фиксированный слот времени в рамках цикла).
	3. Прозрачный режим (Transparent Mode). Приоритет процессора.(Передача данных, когда процессор не взаимодействует с памятью).

Достоинства DMA:
	
	1. Скорость.
	2. Эффективность. Снижает нагрузку на процессор.
	3. Параллелизм: DMA может иметь несколько каналов для параллельной работы.
	4. Интерактивность, так как процессор разгружен от "рутины".

Недостатки DMA:
	
	1. Проблемы совместимости. (переферия cpu и память должны уметь с ним работать)
	2. Сложность при непоследовательном доступе к памяти.
	3. Ограниченный контроль за системной шиной. Синхронизация работы процессора и DMA.
	4. Конфликты использования DMA разными устройствами ввода-вывода.



### Вопрос_20. Параллелизм уровня задач. Кооперативная многозадачность. Принцип работы и подходы к реализации. Примеры использования. Достоинства и ограничения. Зелёные процессы. Проблема синхронизации процессов по управлению и по данным. Сравнение с альтернативами.

---------------- НАЧАЛО ОЧЕРКА О ПАРАЛЛЕЛИЗМЕ

Для начала стоит очеркнуть понятия Parallelism и Concurrency из английского языка. Parallelism подразумевает выполнение нескольких задач параллельно несколькими работниками, когда как Concurrency подразумевает выполнение нескольких задач параллельно одним работником.

Паралеллизм уровня задач в рамках архитектуры фон Неймана представить тяжело - машина фон Неймана рассчитана на единый поток инструкций, условно вечно выполняющийся процессором. 

Обеспечить параллелизм на уровне задач можно:
	
	1. Кооперативной многозадачностью(Cooperative multitasking), соответствующей архитектуре фон Неймана
	2. Вытесняющей многозадачностью(Preemptive multitasking)(Истинной многозадачностью)

---------------- КОНЕЦ ОЧЕРКА О ПАРАЛЛЕЛИЗМЕ

Кооперативная многозадачность - Многозадачность, при которой следующая задача выполняется, когда текущая задача явно объявит о готовности отдать процессорное время.

Кооперативная многозадачность получает все ресурсы компьютера. Фоновые задачи заморожены. Приложения делят процессор, передавая управление следующему.

Вычислительные механизмы кооперативной многозадачности:
	
	1. Механизм остановки выполнения задачи: добровольная передача управления "диспетчеру".
	2. Механизм сохранения состояния задачи: регистры, стек, состояния сопроцессоров, память, ввод-вывод, кеш, состояние предсказателя переходов, и т.п.
	3. Механизм планирования — какой задаче отдать процессорное время следующей.
	4. Механизм возобновления остановленного процесса: восстановление состояния и передача управления.
	5. Механизмы изоляции задач: независимое выполнение, безопасность.
	6. Механизмы взаимодействия между задачами: передача данных и сигналов, общие ресурсы.

Подходы реализации:
	
	1. Имитация через конечные автоматы. (осталась разве что во встроенных системах)
	2. С диспетчером задач на уровне ОС/VM/Программного кода

Практическое применение: 
		
	Пакетный режим и медленный ввод-вывод (в мейнфреймах), чтобы освободить процессор на время I/O.
	Простые встроенные системы, bare-metal программирование.
	Realtime. Статическое планирование.
	Оптимизации систем, требующих частого переключения задач (ngnix/apache)

Достоинства кооперативной многозадачности:
	
	1. Контроль за ресурсами со стороны задачи.
	2. Известные точки остановки. Отсутствие гонок.
	3. Легкость и эффективность (при программной реализации).

Недостатки кооперативной многозадачности:
	
	1. Контроль за ресурсами осуществляется задачей. (злоупотребление приводит к проблемам)
	2. Сбой задачи может быть глобальным.
	3. Низкая эффективность и трудоёмкость ввода-вывода.
	4. Сложность разработки интерактивных приложений


Зелёный процесс - виртуальный процесс, чьё вычислительное время регулируется библиотекой или виртуальной машиной, а не нативной ОС. Они используются для реализации многозадачности в однопоточных системах, или некоторых высокоуровневых окружениях вроде виртуальных машин некоторых языков программирования. 



### Вопрос_21. Параллелизм уровня задач. Вытесняющая многозадачность. Механизмы переключения задач. Примеры использования. Достоинства и ограничения. Проблема синхронизации процессов по управлению и по данным. Сравнение с альтернативами.

См. очерки о параллелизме в начале вопроса 20. 

Вытесняющую многозадачность также называют истинной.

В вытесняющей многозадачности ОС передаёт управление между программами в случае завершения операций ввода-вывода, событий в аппаратуре компьютера, истечения таймеров и квантов времени, поступления сигналов.

Распределение времени осуществляется планировщиком.

Переключение процессов происходит буквально между двумя любыми инструкциями 

Возможна мгновенная реакция на действия пользователя. 

Вычислительные механизмы вытесняющей многозадачности:
	
	1. Вместо механизма остановки задачи механизм прерывания процесса — забрать процессор у задачи независимо от её желания.
	2. Механизм сохранения состояния задачи: регистры, стек, состояния сопроцессоров, память, ввод-вывод, кеш, состояние предсказателя переходов, и т.п.
	3. Механизм планирования — какой задаче отдать процессорное время следующей.
	4. Механизм возобновления остановленного процесса: восстановление состояния и передача управления.
	5. Механизмы изоляции задач: независимое выполнение, безопасность.
	6. Механизмы взаимодействия между задачами: передача данных и сигналов, общие ресурсы.



### Вопрос_22. Система прерываний. Виды прерываний. Механизм обработки прерываний по шагам. Задачи, решаемые механизмом прерываний. Сторожевой таймер.

О прерываниях см. очерк в вопросе 19

Пример работы системы прерываний: Сторожевой таймер (Watchdog timer)

Сторожевой таймер - аппаратно реализованная схема контроля от зависания системы. 

Watchdog timer ждёт, в течении заданного промежутка, сигнала "жизни" от процессора. 
В случае, если процессор его не отправляет, таймер перезагружает устройство. 



### Вопрос_23. Параллелизм уровня задач. Проблемы совмещения, изоляции и взаимодействия задач между собой. Методы разрешения данных проблем (с точки зрения опыта программиста и пользователя): распределение по адресному пространству, банки памяти, сегментная организация памяти и виртуальная память.

См. очерки о параллелизме в вопросе 20

Параллелизм требует:
	
	1. Обеспечить совмещение и изоляцию между задачами.
	2. Обеспечить взаимодействие между задачами.

Случай работы без изоляции? Единое адресное пространство? (плохо)

Требуется изолировать:
	
	1. Адреса инструкций (переходы).
	2. И динамические библиотеки.
	3. Адреса статических данных и переменных.
	4. Динамическая память (куча).
	5. Автоматическая память (стек).

Вопрос изоляции памяти можно решить с помощью:
	
	1. Банков памяти (отчасти)
	2. Сегментации
	3. Виртуальной памяти

Банк Памяти - механизм подключения нескольких чипов памяти к процессору:

	Используется когда:
		1. Память имеет большее адресное пространство, чем процессор.
		2. Расширение машинного слова.
		3. Переключение режима работы (аппаратная изоляция).
		4. Изоляция задач — редко

Не является классичской изоляцией. Раньше мог использоваться для изоляции в системах без аппаратной поддержки оной. 

-------------------------- НАЧАЛО ОЧЕРКА О ВИРТУАЛЬНОЙ ПАМЯТИ И СЕГМЕНТАЦИИ

Сегментация - Разметим память процессора по назначению. Как внутри задач, так и между ними:
	
	1. Сегментная адресация памяти — способ логической адресации памяти, где адрес: сегмент + смещение.
	2. Сегмент — выделенная область адресного пространства определённого размера.
	3. Смещение — адрес ячейки памяти относительно начала сегмента.

Сегментация позволяет:
	
	1. Независимая адресация внутри сегментов (нет коллизиям).
	2. Управление доступом (чтение, запись). Запрет доступа к "чужим" сегментам.
	3. Взаимодействие задач через общий сегмент.
	4. Изоляция программных модулей, динамические библиотеки (ПО — 1, data — N).
	5. Перекрытие сегментов (см. скриншот 11.png)

Достоинства сегментации:

	1. Таблицы сегментов относительно малы.
	2. Таблицы сегментов просты в обработке и перемещении.
	3. Средние размеры сегментов больше, чем размеры большинства страниц, что позволяет хранить в сегментах больше данных процесса.
	4. Отсутствует внутренняя фрагментация.

Недостатки сегментации:

	1. Сложна в поддержке со стороны компилятора, ПО.
	2. Использование требует участие программистов (количество сегментов, размер сегментов).
	3. Подвержена серьезной внешней фрагментации.
	4. На сегодня — считается устаревшей и имеет ограниченную поддержку со стороны ОС (Linux).

! Внутренняя фрагментация - когда выделяется больше памяти чем запрашивалось. Лишняя не используется.
! Внешняя фрагментация - свободная память в процессе выделения или освобождения разделяется на мелкие блоки и в результате не обслуживаются некоторые запросы на выделение памяти.

Виртуальная память - Предоставим каждой задаче своё независимое адресное пространство.
Пусть каждый процесс думает, что всё адресное пространство его:
	
	1.Разделяем виртуальное адресное пространство на страницы (все).
	2. Отображаем используемые страницы в физическую память. 32 бит адреса — 4 Гб.
	3. Если используемых страниц больше, чем физической памяти → выгружаем на диск до востребования.

Виртуальная память позволяет:
	
	1. Прозрачно для программиста изолировать задачи.
	2. Нелинейное физическое размещение данных.
	3. Не фиксировать объём памяти, используемый задачей.
	4. Использовать больше памяти, чем есть физически. Выгрузка на диск части задачи (задач).
	5. Права доступа. Отображение страниц на разные адресные пространства.

Достоинства виртуальной памяти:
	
	1. Прозрачна для программистов.
	2. Работа с "бесконечной" памятью, динамическое распределение памяти.
	3. Отсутствует внешняя сегментация.
	4. Повышает общую стабильность системы (аналогично вытесняющей многозадачности). (жадный процесс будет выгружен на диск).

Недостатки виртуальной памяти:
	
	1. Большой объём таблиц страниц, длительный поиск (кеш).
	2. Высокие накладные расходы (ввод-вывод, перенос страниц и т.п.)
	3. Не позволяет осуществить изоляцию внутри адресного пространства.
	4. Непредсказуемая длительность доступа к памяти.
	5. Высокая сложность реализации.


-------------------------- КОНЕЦ ОЧЕРКА О ВИРТУАЛЬНОЙ ПАМЯТИ И СЕГМЕНТАЦИИ

Взаимодействие между работающими задачами:
Типовые виды задач(условно):
	
	1. Main/kernel - исходный поток инструкций
	2. Прерывания - особый код обработчиков прерываний
	3. Потоки - работают в адресном пространстве процесса. Прямой доступ к его данным.
	4. Процессы - изолированные адресные пространства. Нет прямого доступа.
	5. Зелёные потоки - В рамках Run-Time или виртуальной машины.

Проблемы взаимодействия потоков между собой:
	
	1) непредсказуемая последовательность исполнения инструкций с недетерминированным результатом.
		Решение - искуственная синхронизация процессов:
			1. Атомарные операции: compare&swap, store conditional и т.п.
			2. Mutex (0/1), Semaphore (0..N).
			3. [Software] Transactional Memory ([S]TM).
			4. Process Network, Promise, Futures, Actor-Model..
	2) Проблема доступа к изолированной памяти
		Решение - инструменты для взаимодействия потоков, общие ресурсы:
			1. Shared Memory
			2. Signals
			3. IO: Network, Files, Pipes



### Вопрос_24. Сегментная и виртуальная память. Решаемые задачи и принципы работы. Проблема фрагментации. Достоинства и недостатки.
	
	СМОТРЕТЬ ОЧЕРК О ВИРТУАЛЬНОЙ ПАМЯТИ И СЕГМЕНТАЦИИ В ВОПРОСЕ 23



### Вопрос_25. Иерархия памяти (явная и скрытая). Виды памяти. Особенности использования на практике. Устройство памяти с произвольным доступом. Устройство и принцип работы ROM, SRAM, DRAM ячеек.

Иехрархия памяти в компьютерах(от самых дорогих и быстрых к медленным и дешёвым):
	
	- CPU и его составляющие
	- разновидности RAM
	- Solid State Drives
	- Mechanical Hard Drives
Куда-то сюда можно ещё впихнуть сетевые хранилища

Задачи хранения данных:
	
	1. Исходные данные, необходимые для запуска системы.
	2. Рабочие данные, создаваемые и изменяемые в процессе работы системы.

Проблема: с ростом скорости памяти растёт её стоимость (производство и размещение).
Почему она не решаема? Потому что если нам нужен большой объём быстрой памяти, то столкнёмся либо с её высокой стоимостью, либо с высокой стоимостью её размещения. Представим пример: изобретут новую память. Наша память будет вытеснена с рынка, и новая "быстрая" память займёт нишу. И внутри этой "быстрой" памяти уже будет условно медленная и быстрая. И мы опять зададим себе этот вопрос. 

Иерархия памяти с точки зрения разработчика: 

Явная иерархия памяти - регистры, DRAM, SRAM, диски, альтернативные хранилища. Посыл - используйте с умом.

Скрытая иерархия - Модель одна память, одно адресное пространство. Место реального хранения зависит от способа использования. Определяется прозрачно для разработчика. Послы: YOU WILL OWN NOTHING AND BE HAPPY.

Типы доступа к памяти:
	
	1. с произвольным доступом RAM. Задержка доступа не зависит от истории запросов.
	2. С последовательным (Жесткие диски, магнитные ленты) Задержка при смене адреса. Хорошая скорость последовательной записи/чтения.
	3. Гибридные (библиотека магнитных лент, векторные операции) экзотика...

RAM - Память с произвольным доступом. Доступ происходит так(4 слова на 3 бита. 2 битный адрес): | Адрес ячейки (2 бита) |,  |дешифратор (активирует линию 1 из 4) |, | линия активрующая ячейки требуемого машинного слова |, |линия, на которую выставляется/читается значение бита определённой позиции |, | ячейка памяти | ???

Типовые реализации ячеек памяти:
	
	1. на основе триггеров. Много транзисторов * бит, быстро, много $
	2. ROM. <=1 транзистор * бит, Read Only Memory. Просто за-hardco-женные значения аппаратуры.
	3. SRAM мало транзисторов * бит, очень быстро, 1000$ за ГБ
	4. DRAM 1 транзистор * бит, просто быстро, 10$ 10 ГБ
Обычно SRAM - внутри cpu, DRAM - та самая addressable RAM.

ROM - Read Only Memory. Реализует только чтение (bitline?????)
	
	Реализация:
		Физическое не-размещение транзисторов для записи на производстве
		Пережигание перемычек после однократного программирования(PROM)

SRAM - Static Random Access Memory
	
	Хранит данные с помощью группы транзисторов. 4 - инверторы, 2 - доступ
	Быстрый R/W
	Значение хранится до отключения питания
	Требует большое количество транзисторов (низкая плотность ячеек)

DRAM - Dynamic Random Access Memory
	
	Состояние памяти хранится в конденсаторе. 
	1. Состояние конденсатора считываемо лишь раз
	2. Состояние конденсатора утекае
	3. Требуется контроллер памяти для регенерации
		Увеличивет длительность доступа
		Блокирует доступ к памяти во время регенерации
	4. Один транзистор и конденсатор на ячейку памяти

В эру до 8086 процессоров существовала отдельная техника оптимизации кода - расположение обращений к памяти между регенерацией DRAM, вызывающейся контроллером (DRAM Refresh)(так как если обращение попадало на Refresh, то программа ждала его завершения прежде чем выполнить операцию над памятью). Но, уже во времена 8086, DRAM Refresh стал происходить настолько прозрачно для программиста и эксплуататора компьютера, что как-либо синхронизировать с ним свой код стало в общем невозможным. 



### Вопрос_26. Механизм кеширования в компьютерных системах, принцип локальности. Функционирование кеш памяти процессора (чтение, запись). Виды кеш промахов.  Механизм вытеснения (LRU, PLRU).

Кеш - промежуточный буфер с быстрым доступом, содержащий информацию, которая может быть запрошена с наибольшей вероятностью. 

Свойства:
	
	1. Малый объём быстрой памяти для текущих данных
	2. Целесообразен, если доступ к памяти неравномерный
	3. (реже) Смена интерфейся: процессор - кеш - память

Кеши в компьютерных системах применяются на всех уровнях, но в данном случае идёт речь о процессоре.

Противоречие:
	
	1. Много данных. Кеши работают плохо, так как имеют низкую временную или пространственную локальность. То есть кеш не ускорит программу, которая редко один и тот же раз обращается к одной и той же памяти, но при этом, в таком случае, его потребление будет высоко.
	2. Кеши работают хорошо, когда локальность высока. При этом большая часть кеша простаивает. То есть, если программа часто обращается, к одному и тому же участку памяти, то кеш будет эффективен, и при этом, его расход будет низким. 

Кеш. Функционирование
	
	1. Кеш состоит из набора кеш-линий (блоков кеша, записей). 
	2. Кеш-линия ассоциирована с элементом в медленной памяти
	3. кеш-линия имеет идентификатор (тег), определяющий соответствие
	4. Доступ к памяти реализуется прозрачно для программиста
	5. Память может быть изменена вне зависимости от кеша (DMA, другое ядро)

Кеш. Чтение данных:

	1. Тег найден -> кеш-попадание. Данные читаются в процессор из кеша
	2. Тег не найден -> кеш-промах. Запрашиваем данные из памяти или следующего кеша. Выбираем линию для замещения:
		Если пустая - подходит
		Все заняты - принимаем решение о вытеснении линии
		Длительность получения данных произвольна - т.к. возможен многоуровневый кеш, возможна блокировка памяти
	Уровень попадания(hit rate) - основная характеристика эффективности кеша.

Кеш. Запись данных(кеш попадание):
	
	1. Немедленная запись (Write through). Изменение вызывает синхронное обновление памяти. Иногда медленнее чем без кеша.
	2. Отложенная запись (Write back). Обновление памяти при вытеснении кеш линии, периодически, или по запросу.
		Требует хранения признака модификации ("грязный")
		Два обращения: запись вытесняемого и чтение необходимого
		Группировка изменений, сокрытие промежуточных состояний
		Возможно неконсистентное состояние кеша и памяти. Для процессора - невидимое, для других устройств (DMA) - требуется принудительная запись. 
	3. Гибридные варианты. Пример: немедленная запись с буферизацией

В архитектуре x86 для конфигурации режимов кеширования регионов памяти, существует группа model-specific регистров, называемых MTRR. 

Кеш. Запись данных(кеш промах):
	
	1. Запись с размещением (Write allocate, fetch on write).
		Данные загружаются в кеш, после в них вносится исправление
		Поведение аналогично промаху по чтению
	2. Запись без размещения (No-Write Allocate, Write Around)
		Запсиь производится напрямую в память или через буфер

Кеш-промахи. Разная информация и операции:
	1. чтение данных - средняя задержка. Может компенсироваться параллелизмом уровня инструкций.
	2. Запись данных - минимильная задержка. Запись может быть отложена
	3. Чтение инструкций - большая задержка. ПРоцессор простаивает в ожидании инструкции. 

Кеш. Внутреннее устройство:
	
	1. Поиск кеш-линии по тегу (компораторы)
	2. Вытеснение, replacement (определение нужной кеш-линии)
	3. Предзагрузка (prefetch) данных и инструкций
	4. Взаимодействия с памятью (группировка операций и т.п.)
	5. Синхронизаций кешей разных уровней
Больше данных -> больше логики
Масштабирование по времени и площади

2 линии, 2 компаратора -> 1 такт
2 линии, 1 компаратор -> 2 такта

Кеш. Вытеснение и замещение
	
	1. Ключевой механизм: эвристика выбора более не требующейся кеш-линии среди доступных
	2. В процессорах применяются достаточно простые алгоритмы - Least Recently Used(LRU) и Pseudo-LRU
	3. Возможные модификации: Victim cache - сперва отделить, потом вытеснить(отдельная линия для вытесняемой записи). Запрет кеширования(если мы знаем, что наша память не локальна и не кешируется, то можно запретить кеш перед доступом). 

Pseudo-LRU:
	
	1. бинарное дерево
		Вершины хранят путь:
		left(0) / right(1);
		листья - кеш-линии
	2. Поиск записи для вставки или вытеснения:
		спуск по дереву согласно значениям в вершинах
		инверсия всех пройденных вершин
	3. Кеш попадание - инверсия пути от корня до листа
	4. Значительно "легче" LRU



### Вопрос_27. Устройство кеш-памяти процессора. Ассоциативность кеш-памяти (полностью ассоциативная, прямое отображение, множествено-ассоциативный кеш). Принципы работы. Детальное описание принципов работы кеш-памяти с разными вариантами ассоциативности.

Смотреть вопрос 26 про кеш. 

Ассоциотивность кеш памяти(поиск кеш линии по тегу) - это политика размещения данных памяти в кеше для оптимизации поиска.
Аналогия: поиск в массиве O(n), btree O(log(n)), hashmap O(1)-O(n)

Тег - идентификатор области памяти, сохранённой в кеш-линии

Что же хранить как тег?
Варианты:
1. Полный адрес - плохо, много памяти, много больших компараторов
2. Младшие биты - не нужны, если работать с блоками, а не байтами
3. Средние биты - Циклически повторяются в адресах памяти
	Принцип временной и пространственной локальносто
4. Старшие биты - Относительно уникальны, если используются

Полностью ассоциативный кеш(храним старшие и средние биты как тег):
	
	любая строка памяти может быть отображена в любую кеш-линию
	1. Лучшая эффективность
	2. Очень много логики у компараторов и вытеснения

Кеш с прямым отображением(Direct mapping):
	
	Каждая ячейка может быть отображена только в 1 кеш линию (одна кеш линия - много ячеек)
	Средняя часть - номер линии
	Средние биты адреса используются как индекс для кеш памяти
	Старшие биты используются как тег
	https://en.wikipedia.org/wiki/Cache_placement_policies
	1. Меньше памяти для тегов
	2. Один меньший компаратор
	3. Нет вытеснения (однозначно)
	4. Коллизия и техническая выгрузка


Множественно-ассоциативный кеш:
Кеш с прямым отображением (1 банк), воспроизведённый N раз
	
	1. Больше ассоциативность, ниже скорость, выше эффективность
	2. Выбор банка осуществляется на основе алгоритма вытеснения


### Вопрос_28. Иерархия кеш-памяти процессора. Причины множества уровней кеша. Разделённый/унифицированный, включающий/исключающий, частный/общий. Типовые уровни кеша в современных процессорах.

Смотреть вопрос 26 про общую информацию о кеше

Зачем нужно много уровней кеша?
	
	Разный кеш имеет разный размер и разную стоимость. Таким образом, не помешало бы иметь несколько для разных задач. 

Свойства кеша определяются:
	
	1. технологией ячеек памяти
	2. устройством кеша (размер, ассоциативность и т.д.)

Задачи кеша:
	
	1. Повышение скорости доступа 
	2. Синхронизация проц. ядер
	3. Оптимизация интерфейсов

Способы организации многоуровневых кешей:
	
	1. Разделённый/унифицированный (разеляем ли мы данные лежащие в разных кешах)
	2. Включающие/исключающие (может ли быть уместным дублирование данных)
	3. Частные/общие (сколько ядер имеют доступ)

Разделённый(Banked)/Унифицированный(Unified) - Кеш-память может быть реализована одним или несколькими банками памяти. Иметь один канал доступа, или несколько.

	Принцип разделения:
		По типу данных (кеш данных, инструкций, микрокода)
		По процессорному ядру
	Достоинства разделённого кеша:
		Высокая скорость (много каналов)
		Возможность адаптации устрйоства кеша под специфику использования
	Недостатки разделённого кеша:
		Усложнение процессора
		Конфликты между банками кеш памяти
В общем, разделённый кеш это круто, но он очень сильно усложняет устройство компьютера. Примерно как с Гарвардской архитектурой. 

Включающий/Исключающий кеш:
Должен ли кеш одного уровня включать в себя кеш другого уровня?(как регистры в x86)
	
	1. Включающая(Инклюзивная) - данные кеш-линий дублируюся. Доступ происходит быстрее. Выгрузка L1 не может привести к выгрузке L2, но часть памяти теряется
	2. Исключающая(Эксклюзивная) - данные не дублируются, память используется эффективнее.
	3. Гибридный вариант (NINE(Non-Inclusive, Non-Exclusive))

Частный(Private)/Общий(Shared) кеш:
характеризует доступ процессорных ядер к хешу

	1. Частный кеш - ядро имеет эксклюзивный доступ к кешу
		скорость ядра
		дублирование и конфликты
	2. Общий кеш - несколько ядер имеет доступ к кешу
		меньше кеш промахов
		нет дублирования
		постоянная синхронизация доступа

В современных компьютерах тип кеша рознится от уровня к уровню.

Уровни кеширования в современных процессорах:
	
	L0(опционален) - специальный кеш для: стека, int/float чисел. Обычно доступен за такт.
	L1 - быстрый, неотъемлемая часть cpu. Обычно разделён(Banked)
	L2 - Обычно часть cpu. 128 Кб - 12Мб. Обычно общий(Shared)
	L3 - до 24 Мб и более. Синхронизация данных в многоядерных cpu. (для переключения процессов ОС)
	L4 (экзотика для серверов и мэйнфреймов). Оптимизация интерфейса доступа к памяти



### Вопрос_29. Когерентность кеш-памяти. Возможные состояния кеш линий. Механизмы обмена информацией между кешами: справочник, отслеживание и перехват. CAP теорема.

Смотреть вопрос 26 про общую информацию о кеше. 27 о типах кеша.

Когерентность памяти (в информатике) — свойство компьютерных систем, заключающееся в том, что два или более процессора или ядра могут получить доступ к одной области памяти.


Возможные состояния кеш линий(MOESI):
	
	1. Modified. L - свежие уникальные данные





1. Закон Мура. Закон Деннарда. Закон Амдала. Их роль в развитии компьютерных систем. Источники роста производительности процессоров тогда и сегодня.
1. Проблема обеспечения реального времени в современных компьютерных системах. Влияние параллелизма уровня инструкций, языков программирования высокого уровня, многозадачности и организации памяти.
1. Уровневая организация компьютерных систем. Элементы уровня организации. Уровневый архитектурный стиль. Примеры. Явление разделения на уровни (disaggregation) и их смешения. Документирование инструментальных цепочек.
1. Особенности реализации структурного программирования в фон Неймановских процессорах. Работа с памятью, регистрами. Реализация процедур. Реентерабельность.
1. Уровни параллелизма. Параллелизм уровня бит. Низкоуровневый параллелизм. Параллелизм уровня инструкций. Параллелизм уровня задач. Примеры и особенности.
1. Параллелизм уровня инструкций. Суперскалярные процессора. Особенности и принципы работы. Сравнение с VLIW и практика использования. Достоинства и недостатки. Барьеры памяти.
1. Параллелизм уровня инструкций. VLIW процессора. Особенности и принципы работы. Сравнение с суперскалярными и практика использования. Достоинства и недостатки. Барьеры памяти.
1. Программируемые логические контроллеры (ПЛК). Область применения. Особенности. Языки программирования.
1. Программируемые логические интегральные схемы (ПЛИС). Область применения. Особенности. Устройство. Задачи высокоуровневого синтеза, достоинства и недостатки.
1. Классификация Флинна. Выделяемые классы и примеры машин этих классов. SIMT архитектура.
1. Классификация Дункана. Цели и задачи, классификация первого уровня. Синхронные архитектуры (векторные, SIMD, ассоциативные массивы, систолические). Принципы их работы и примеры.
1. Классификация Дункана. Цели и задачи, классификация первого уровня. MIMD архитектуры (распределённая и разделяемая память). Примеры и принципы их работы.
1. Классификация Дункана. Цели и задачи, классификация первого уровня. MIMD парадигмы (MIMD/SIMD, потоки данных, редукционные, wavefront) . Примеры и принципы их работы.


# P33082+P33092+P33102

1. Как работает механизм копирования при записи (Copy-on-Write, COW) в файловой системе Linux и какова его ценность? Что такое состояние гонки? Перечислите и разъясните механизмы предотвращения состояния гонки в ядре Linux. (Лапин Алексей Александрович -- Dirty COW (CVE-2016-5195) - уязвимость ядра Linux)

1. Формальная, функциональная и физическая Верификация в контексте микропроцессоров. Расскажите о её вышеперечисленных типах и их отличиях. Соотнесите каждый метод верификации с этапом разработки микропроцессора, на котором этот метод целесообразнее всего применять. (Панин Иван Михайлович -- Pentium fdiv bug)

1. В Unicode кодировках (UTF-8, UTF-16, …) есть такие понятия как Code Unit, Code Point, Grapheme Cluster. Дайте определения этим понятиям, объясните их взаимосвязь, приведите пример для наиболее популярных Unicode кодировок (UTF-8, UTF-16, UTF-32). (Гулямов Тимур -- Как языки программирования пытаются работать со строками?)

1. В чём заключается суть методов обфускации и виртуализации, применяемых в программах протекторах для защиты кода от анализа извне? (Юнусов Роман -- Методы DRM защиты)

1. Расскажите об основых проблемах синхронизации между клиентами и серверами в сетевых играх: лагах, джиттере и потере пакетов. В чём заключаются и как методы предсказания ввода и расчета траектории помогают улучшить ситуацию? (Андриенко Сергей Вячеславович -- Основные проблемы синхронизации между клиентами и серверами в сетевых играх. Nocom Minecraft exploit.)

1. Как связаны система прерываний, режимы работы процессора и виртуальная память в рамках работы операционной системы при обработке исключения? (Тюрин Иван Николаевич -- Роль процессора в работе ОС на примере xv6-riscv.)

1. Как доменная адаптация, стресс тестирование и построение архитектуры моделей и структур данных помогают решить проблему обобщения в контексте ML?(Дробыш Дмитрий Александрович -- Проблемы современного ML.)

1. Сравните кодировки UTF-8 и UTF-16 по количеству байт, блоков, оперативности, ASCII-совместимости. В каких случаях разумно использование той или иной кодировки? Почему? (Абдурасул Кызы Мээрим -- История кодировок: Откуда такой зоопарк?)

1. Как с помощью page fault можно определить длину недокументированной инструкции, даже если онэто ошибочная инструкция и у нас нет прав на исполнение такой? (Никита Манжиков -- Аудит/тестирование x86 процессоров.Нахождение аномалий. )

